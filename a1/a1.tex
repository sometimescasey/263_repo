\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{lstlinebgrd}
\usepackage{amssymb}

% --------- break urls at hyphens in addition to slashes
\usepackage[hyphens]{url}
\usepackage{hyperref}

% ------------ paired delimiters -------------- %
\usepackage{mathtools} 
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

% ---- colors ----- %
\definecolor{darkgreen}{RGB}{51,102,0}
\definecolor{darkblue}{RGB}{0,0,204}
\definecolor{mauve}{RGB}{102,0,0}

% ------------ code formatting, lstlisting -------------- % 
\lstset{basicstyle=\footnotesize\ttfamily,
escapechar=|,
mathescape=true,
tabsize=2,
showstringspaces=false,}

\lstdefinestyle{CStyle}{ %
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{darkgreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{darkblue},       % keyword style
  stringstyle=\color{mauve},     % string literal style
  tabsize=2,					% reduce tab size
  basicstyle=\footnotesize\ttfamily,	% small typewriter font
  showstringspaces=false,		% don't show squat spaces
}


\title{CSC263 Assignment 1}
\author{Juanxi Li}
\date{May 19, 2018}

\begin{document}

\maketitle

\section*{Sources Consulted}

\begin{itemize}
    \item Lecture 1 Notes - Introduction, Complexity Review
    \item \url{https://medium.com/@ssbothwell/counting-inversions-with-merge-sort-4d9910dc95f0}{}
    \item Delete a node from Binary Search Tree: \url{https://www.youtube.com/watch?v=gcULXE7ViZw}

\end{itemize}

\section*{Problems}

\begin{enumerate}
    \item Inversions
    \begin{enumerate}
        \item (3,4), (3,5) and (4,5) where A[3] = 7, A[4] = 5, and A[5] = 1.
        
        \item The completely reverse-sorted descending-order array with items \{n, n-1, n-2, ... , 2, 1\} has the most inversions. It has $1 + 2 + 3 +...+ (n-1) + n$ inversions, or \(\frac{n(n-1)}{2}\). This is also the worst-case runtime of insertion sort.
        
        \item Runtime of insertion sort, above the best case $\theta$(n), is proportional to \# of inversions. \\ \\
        Pseudo-code of insertion sort from lecture 1 uses an outer loop j which traverses the array from 2 to n. This loop runs $\theta$(n) times. \\ \\
        Inner loop \textbf{i} begins at \textbf{j-1} and traverses backwards, swapping elements as long as A[i] $>$ A[j] (or, in other words, if an inversion exists). Therefore the \# of inversions in the array = \# of swaps that must be made by the inner loop during insertion sort. 
        
        \item Solution is mergesort, which runs in $\theta$(\textit{n}log\textit{n}), with an added line of code to increment an inversion counter during the merge step. This line runs in constant time $\theta$(1); therefore the entire algorithm still runs in $\theta$(\textit{n}log\textit{n}). \newline
        
        Recursively, total inversions = inversions encountered in sorting left half + inversions encountered in sorting right half + inversions between the two halves. \newline
        
        During \texttt{merge()}, the left and right halves are already sorted, and their inversions will already have been recursively counted. So additional inversions can only exist \textit{between} the two halves. When \texttt{merge()} copies a value from the right half back to the main array, it is necessarily an inversion relative to any numbers that remain in the left half. So this is the amount by which we increase the counter. \newline
        
        Derived from pseudo-code in Lecture 1 slides:
        \begin{lstlisting}[
        linebackgroundcolor={%
        \ifnum\value{lstnumber}=2
                \color{green!35}
        \fi
        \ifnum\value{lstnumber}=7
                \color{green!35}
        \fi
        \ifnum\value{lstnumber}=29
                \color{green!35}
        \fi
                },
]
mergeSortInversions(A,p,r) {
    inv = 0; // variable to track inversions
    if (p < r) {
        q = floor((p+r)/2)
        mergeSortInversions(A,p,q)
        mergeSortInversions(A, q+1, r)
        merge(A,p,q,r,inv)
    }
    return inv;
}
            
merge(A, p, q, r, inv) {
    n1 = q - p + 1
    n2 = r - q
    copy A[p,q] to L[1...n1]
    copy A[q+1,r] to R[1...n2]
    L[n1+1] = R[n1+1] = +Inf
    i = j = 1
    for (k=p to r) {
        if (L[i] < R[j]) {
            A[k] = L[i]
            i++
        } else {
            // a value R[j] was taken from the right 
            // side in the process of merging;
            // R[j] must be an inversion relative to 
            // everything remaining on the left side
            A[k] = R[j]
            inv += L.length - i
            j++
        }
    }
}
        \end{lstlisting}
    \end{enumerate}
    
    \item Extract second largest
    
    \begin{enumerate}
    	\item This is the same thing as finding max in array Q and deleting the larger of its two children. Here is a modified version of \texttt{extractMax()} from lecture which accompishes this.
    	\begin{lstlisting}
extractSecondLargest(Q) {
	int secondMax;
	int maxVal;

	// max is at 1, its children are at positions 2 and 3
	
	if (Q[2] == NULL) {      // second largest doesn't exist
		return NULL;
	} 
	else if (Q[3] == NULL) { // Q only has two items
		secondMax = 2;
	} 
	else {                   // compare Q2 and Q3
		if (Q[2] >= Q[3]) { secondMax = 2; } 
		else              { secondMax = 3; }
	}
	
	maxVal = Q[secondMax];	
	
	// swap w last, and delete	
	Q[secondMax] = Q[Q.heapsize];
	Q.heapsize = Q.heapsize - 1;
	maxHeapify(Q, secondMax);
	
	return maxVal;
}
    		
    	\end{lstlisting}
    	
    	\item 
    	\begin{itemize}
    		\item \textbf{Why element is second largest:} because in our implicit definition of the heap as an array, the maximum element is always stored in position 1, and its children are stored in positions 2 and 3. \\
    		
    		We compare nodes 2 and 3, returning the larger value. This is the second-largest value, behind max. \\
    		\item \textbf{Why maintains heap property:} Shape is maintained by swapping the second-largest with the last item and removing the last item. Heap property is maintained by calling \texttt{maxHeapify()} on the position previously occupied by the second-largest, which bubbles that value down until heap property is restored. \\
    		\item \textbf{Why worst-case run-time is O(logn):} Locating the second-largest item and swapping with last item occurs in constant time. max() is found in $\theta$(1) since it's just the first item, and we make at most one comparision between the children at Q[2] and Q[3] if they exist. The swap takes constant time. \\
    		
    		 \texttt{maxHeapify()} bubbles down at most h times where h is height of tree, which is $log(n)$ for binary heap. \\
    	\end{itemize}
    	
	\end{enumerate}
	
	\item Heap Delete
	
	\begin{enumerate}
		\item This will be very similar to the pseudocode from Q2, but we delete item $i$ instead of item 2 or 3. I assume the function should return the item.
		\begin{lstlisting}
heapDelete(A, i) {	
	int iVal = A[i];	
	
	// swap w last, and delete	
	A[i] = A[A.heapsize];
	A.heapsize = A.heapsize - 1;
	maxHeapify(A, i);
	
	return iVal;
}
		\end{lstlisting}
		
		\item 
		\begin{itemize}
			\item \textbf{Why works:} Swapping $i$th node with last element, and then deleting last element (by shortening the array) maintains heap shape. Calling \texttt{maxHeapify()} on the subtree rooted at $i$ ensures that the new $i$th element bubbles down until the heap property is restored. Outside of this subtree, no other part of the heap is changed.
			\item \textbf {Why O(logn):} Location of node to be removed is already known and supplied via integer $i$. Swap takes constant time. After swap, \texttt{maxHeapify()} bubbles element $i$ down max $h_i$ times, where $h_i$ is height of subtree rooted at $i$. Worst case, $i$ is the root and $h_i$ = height of entire tree, which is $log(n)$ for complete binary tree.
		\end{itemize}
		
	\end{enumerate}
	
	\item d-ary heap \\
	Answers are given for \textbf{root position at $i$ = 0}, as this was the easiest for actually testing code.
	\begin{enumerate}
		\item For any node in $d$-ary array with index $i$:
		\begin{itemize}
			\item parent: $\floor{\frac{i-1}{d}}$
			\item children: $\{ni+1, ni+2, ... , ni+d\}$
		\end{itemize}
		\item (n is \# of items; i.e. item n exists at index n-1) \\
		height: $\ceil{log_d(d-1) + log_d(n) -1 } = \theta(log_d(n))$
		\newpage
		\item I thought the best way to understand this question would be to write a working implementation in C (not all functions shown):
		
\begin{lstlisting}[language=C,style=CStyle]
#define DARY 3 // <- just as example, i.e. ternary heap

void maxHeapify(int *arr, int i, int *heapsize) { 
	// maxHeapify the heap rooted at i
	// each node has DARY children
	int largest = i;
	int dary = DARY;
	for (int k = 1; k <= dary; k++) {
		int child = dary*i + k;
		if (arr[child] > arr[largest]) {
			largest = child;
		}
	}

	if (largest != i) {
		// swap with largest, 
		// then maxHeapify the tree rooted at largest
		exchange(arr, i, largest);
		maxHeapify(arr, largest, heapsize);
	}
}

int extractMax(int *arr, int *heapsize) {
	if (*heapsize < 1) {
		printf("ERROR: heap is empty. Nothing to return.\n");
		return INT_MIN; // int placeholder for -inf
	} 
	else {
		int max = arr[0];
		// swap root with last item, get rid of last item
		int last = arr[*heapsize-1];
		arr[0] = last;
		*heapsize = *heapsize - 1;
		maxHeapify(arr, 0, heapsize);
		return max;
	}
}
		\end{lstlisting} 
		
		\textbf{\texttt{extractMax()} runtime analysis:}
		\begin{itemize}
		\item \texttt{int max} is found in constant time (always the root).
		
		\item \texttt{maxHeapify()} is recursively called, starting with the root position; worst case, the value there needs to bubble all the way to the bottom of the tree, or \textit{h} times.
		Per question b, height of a d-ary tree is $\theta(log_{d}(n))$.
		
		\item Therefore worst-case runtime of \texttt{extractMax()} for d-ary tree is $O(log_{d}(n))$.
		
		\end{itemize}
		\newpage
		\item Implementation of increaseKey():
\begin{lstlisting}[language=C,style=CStyle]
void increaseKey(int *arr, int i, int key) {
	if (key < arr[i]){ printf("ERROR: %d is less than current arr[i] %d\n", key, i); }
	else {
		arr[i] = key;
		while (i > 0) {
			int j = (i-1) / DARY; // parent
			if (arr[j] >= arr[i]) {
				break; // parent is greater, all is well
			} else {
				// parent is smaller; swap them
				exchange(arr, i, j);
				i = j;
			}
		}
	}
}
\end{lstlisting}
		
		\textbf{\texttt{increaseKey()} runtime analysis:}
		\begin{itemize}
		\item The \texttt{while} loop runs as long as the current node (at position i) being checked has a parent, and while \texttt{arr[i]} is greater than its parent. The max number of times this can happen is the \# of edges between \texttt{i} and the root. Worst case, \texttt{i} is at the bottom of the tree, meaning the loop can occur maximum \textit{h} times, where \textit{h} is the height of the tree.
		\item Per question b, height of a d-ary tree is $\theta(log_{d}(n))$.
		\item Therefore worst-case runtime of \texttt{increaseKey()} for d-ary tree is $O(log_{d}(n))$.
		\end{itemize}
		
		\item Implementation of \texttt{insert()}:
\begin{lstlisting}[language=C,style=CStyle]
define MAX 10; // <- to help malloc space for array
void insert(int *arr, int key, int *heapsize) {
	if (*heapsize == MAX) {
		printf("ERROR: Heap at max size %d\n", *heapsize);
	} else {
		*heapsize = *heapsize + 1; // expand queue by 1
		arr[*heapsize-1] = INT_MIN; // set new, last item to large negative value
		increaseKey(arr, *heapsize-1, key); // update its priority to "key" and bubble up to right place
	}
}
\end{lstlisting}
\textbf{\texttt{insert()} runtime analysis:}
		\begin{itemize}
		\item \texttt{insert()} makes a single call to \texttt{increaseKey()} after adding the new value to the end of the array. All other lines run in constant time.
		\item Per question d above, \texttt{increaseKey()} worst-case runtime is $O(log_{d}(n))$, so \texttt{insert()} also runs in $O(log_{d}(n))$.
		\end{itemize}
		
		\end{enumerate}
		
\newpage	
	\item 
	\begin{enumerate}
	\item reverse Young Tableau:
	\begin{center}
	\begin{tabular}{| c | c | c | c |}
	\hline
 	15 & 14 & 8 & 4 \\ 
 	\hline
 	12 & 9 & 5 & $-\infty$ \\  
 	\hline
 	3 & $-\infty$ & $-\infty$ & $-\infty$  \\
 	\hline
 	1 & $-\infty$ & $-\infty$ & $-\infty$  \\
 	\hline 
	\end{tabular}
	\end{center}
	
	\item \textbf{The definition of an empty reverse Young tableau} is that all elements are nonexistent = $-\infty$. \\
	
	A reverse Young Tableau requires that in an $m \times n$ tableau:
	
	\[Y[a,b] \geq Y[a+i, b+j] \]
	for \\ 
	$a = 1,2,...,m$ \\
	$b = 1,2,...,n$ \\ 
	$i = 1,2,...m-a$\\ 
	$j = 1,2,...n-b$ \\
	
	There exist no values smaller than -$\infty$; therefore the only tableau that satisfies this constraint for $Y[1,1]$ = -$\infty$ is if all other elements are also -$\infty$.\\
	
	\textbf{The definition of a full reverse Young tableau} is that no elements are $-\infty$. \\
	
	If $Y[m,n] > -\infty$, all elements $Y[a,b]$ for $a\leq m$ and $b\leq n$ must be $\geq$ $Y[m,n]$, or $> -\infty$. Therefore no elements are empty and the tableau must be full.
	
	\end{enumerate}  
	
	
\end{enumerate}

\end{document}
