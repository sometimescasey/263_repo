\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\geometry{margin=1in}

\usepackage{listings}
\usepackage{xcolor}
\usepackage{lstlinebgrd}
\usepackage{amssymb}

% --------- break urls at hyphens in addition to slashes
\usepackage[hyphens]{url}
\usepackage{hyperref}

% ------------ paired delimiters -------------- %
\usepackage{mathtools} 
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}

% ---- colors ----- %
\definecolor{darkgreen}{RGB}{51,102,0}
\definecolor{darkblue}{RGB}{0,0,204}
\definecolor{mauve}{RGB}{102,0,0}

% ------------ code formatting, lstlisting -------------- % 
\lstset{basicstyle=\footnotesize\ttfamily,
escapechar=|,
mathescape=true,
tabsize=2,
showstringspaces=false,}

\lstdefinestyle{CStyle}{ %
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{darkgreen},    % comment style
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  keywordstyle=\color{darkblue},       % keyword style
  stringstyle=\color{mauve},     % string literal style
  tabsize=2,					% reduce tab size
  basicstyle=\footnotesize\ttfamily,	% small typewriter font
  showstringspaces=false,		% don't show squat spaces
}


\title{CSC263 Assignment 1}
\author{Juanxi Li}
\date{May 19, 2018}

\begin{document}

\maketitle

\section*{Sources Consulted}

\begin{itemize}
    \item Lecture 1 Notes - Introduction, Complexity Review
    \item \url{https://medium.com/@ssbothwell/counting-inversions-with-merge-sort-4d9910dc95f0}{}
    \item Delete a node from Binary Search Tree: \url{https://www.youtube.com/watch?v=gcULXE7ViZw}
    \item Young tableaus: \url{https://ita.skanev.com/06/problems/03.html}
    \item \url{https://kukuruku.co/post/young-tableaux-in-the-tasks-of-searching-and-sorting/}
   	\item \url{http://codinggeeks.blogspot.com/2010/04/young-tableau.html}

\end{itemize}

\section*{Problems}

\begin{enumerate}
    \item Inversions
    \begin{enumerate}
        \item (3,4), (3,5) and (4,5) where A[3] = 7, A[4] = 5, and A[5] = 1.
        
        \item The completely reverse-sorted descending-order array with items \{n, n-1, n-2, ... , 2, 1\} has the most inversions. It has $1 + 2 + 3 +...+ (n-1) + n$ inversions, or \(\frac{n(n-1)}{2}\). This is also the worst-case runtime of insertion sort.
        
        \item Runtime of insertion sort, above the best case $\theta$(n), is proportional to \# of inversions. \\ \\
        Pseudo-code of insertion sort from lecture 1 uses an outer loop j which traverses the array from 2 to n. This loop runs $\theta$(n) times. \\ \\
        Inner loop \textbf{i} begins at \textbf{j-1} and traverses backwards, swapping elements as long as A[i] $>$ A[j] (or, in other words, if an inversion exists). Therefore the \# of inversions in the array = \# of swaps that must be made by the inner loop during insertion sort. 
        
        \item Solution is mergesort, which runs in $\theta$(\textit{n}log\textit{n}), with an added line of code to increment an inversion counter during the merge step. This line runs in constant time $\theta$(1); therefore the entire algorithm still runs in $\theta$(\textit{n}log\textit{n}). \newline
        
        Recursively, total inversions = inversions encountered in sorting left half + inversions encountered in sorting right half + inversions between the two halves. \newline
        
        During \texttt{merge()}, the left and right halves are already sorted, and their inversions will already have been recursively counted. So additional inversions can only exist \textit{between} the two halves. When \texttt{merge()} copies a value from the right half back to the main array, it is necessarily an inversion relative to any numbers that remain in the left half. So this is the amount by which we increase the counter. \newline
        
        Derived from pseudo-code in Lecture 1 slides:
        \begin{lstlisting}[
        linebackgroundcolor={%
        \ifnum\value{lstnumber}=2
                \color{green!35}
        \fi
        \ifnum\value{lstnumber}=7
                \color{green!35}
        \fi
        \ifnum\value{lstnumber}=29
                \color{green!35}
        \fi
                },
]
mergeSortInversions(A,p,r) {
    inv = 0; // variable to track inversions
    if (p < r) {
        q = floor((p+r)/2)
        mergeSortInversions(A,p,q)
        mergeSortInversions(A, q+1, r)
        merge(A,p,q,r,inv)
    }
    return inv;
}
            
merge(A, p, q, r, inv) {
    n1 = q - p + 1
    n2 = r - q
    copy A[p,q] to L[1...n1]
    copy A[q+1,r] to R[1...n2]
    L[n1+1] = R[n1+1] = +Inf
    i = j = 1
    for (k=p to r) {
        if (L[i] < R[j]) {
            A[k] = L[i]
            i++
        } else {
            // a value R[j] was taken from the right 
            // side in the process of merging;
            // R[j] must be an inversion relative to 
            // everything remaining on the left side
            A[k] = R[j]
            inv += L.length - i
            j++
        }
    }
}
        \end{lstlisting}
    \end{enumerate}
    
    \item Extract second largest
    
    \begin{enumerate}
    	\item This is the same thing as finding max in array Q and deleting the larger of its two children. Here is a modified version of \texttt{extractMax()} from lecture which accompishes this.
    	\begin{lstlisting}
extractSecondLargest(Q) {
	int secondMax;
	int maxVal;

	// max is at 1, its children are at positions 2 and 3
	
	if (Q[2] == NULL) {      // second largest doesn't exist
		return NULL;
	} 
	else if (Q[3] == NULL) { // Q only has two items
		secondMax = 2;
	} 
	else {                   // compare Q2 and Q3
		if (Q[2] >= Q[3]) { secondMax = 2; } 
		else              { secondMax = 3; }
	}
	
	maxVal = Q[secondMax];	
	
	// swap w last, and delete	
	Q[secondMax] = Q[Q.heapsize];
	Q.heapsize = Q.heapsize - 1;
	maxHeapify(Q, secondMax);
	
	return maxVal;
}
    		
    	\end{lstlisting}
    	
    	\item 
    	\begin{itemize}
    		\item \textbf{Why element is second largest:} because in our implicit definition of the heap as an array, the maximum element is always stored in position 1, and its children are stored in positions 2 and 3. \\
    		
    		We compare nodes 2 and 3, returning the larger value. This is the second-largest value, behind max. \\
    		\item \textbf{Why maintains heap property:} Shape is maintained by swapping the second-largest with the last item and removing the last item. Heap property is maintained by calling \texttt{maxHeapify()} on the position previously occupied by the second-largest, which bubbles that value down until heap property is restored. \\
    		\item \textbf{Why worst-case run-time is O(logn):} Locating the second-largest item and swapping with last item occurs in constant time. max() is found in $\theta$(1) since it's just the first item, and we make at most one comparision between the children at Q[2] and Q[3] if they exist. The swap takes constant time. \\
    		
    		 \texttt{maxHeapify()} bubbles down at most h times where h is height of tree, which is $log(n)$ for binary heap. \\
    	\end{itemize}
    	
	\end{enumerate}
	
	\item Heap Delete
	
	\begin{enumerate}
		\item This will be very similar to the pseudocode from Q2, but we delete item $i$ instead of item 2 or 3. I assume the function should return the item.
		\begin{lstlisting}
heapDelete(A, i) {	
	int iVal = A[i];	
	
	// swap w last, and delete	
	A[i] = A[A.heapsize];
	A.heapsize = A.heapsize - 1;
	maxHeapify(A, i);
	
	return iVal;
}
		\end{lstlisting}
		
		\item 
		\begin{itemize}
			\item \textbf{Why works:} Swapping $i$th node with last element, and then deleting last element (by shortening the array) maintains heap shape. Calling \texttt{maxHeapify()} on the subtree rooted at $i$ ensures that the new $i$th element bubbles down until the heap property is restored. Outside of this subtree, no other part of the heap is changed.
			\item \textbf {Why O(logn):} Location of node to be removed is already known and supplied via integer $i$. Swap takes constant time. After swap, \texttt{maxHeapify()} bubbles element $i$ down max $h_i$ times, where $h_i$ is height of subtree rooted at $i$. Worst case, $i$ is the root and $h_i$ = height of entire tree, which is $log(n)$ for complete binary tree.
		\end{itemize}
		
	\end{enumerate}
	
	\item d-ary heap \\
	Answers are given for \textbf{root position at $i$ = 0}, as this was the easiest for actually testing code.
	\begin{enumerate}
		\item For any node in $d$-ary array with index $i$:
		\begin{itemize}
			\item parent: $\floor{\frac{i-1}{d}}$
			\item children: $\{ni+1, ni+2, ... , ni+d\}$
		\end{itemize}
		\item (n is \# of items; i.e. item n exists at index n-1) \\
		height: $\ceil{log_d(d-1) + log_d(n) -1 } = \theta(log_d(n))$
		\newpage
		\item I thought the best way to understand this question would be to write a working implementation in C (not all functions shown):
		
\begin{lstlisting}[language=C,style=CStyle]
#define DARY 3 // <- just as example, i.e. ternary heap

void maxHeapify(int *arr, int i, int *heapsize) { 
	// maxHeapify the heap rooted at i
	// each node has DARY children
	int largest = i;
	int dary = DARY;
	for (int k = 1; k <= dary; k++) {
		int child = dary*i + k;
		if (arr[child] > arr[largest]) {
			largest = child;
		}
	}

	if (largest != i) {
		// swap with largest, 
		// then maxHeapify the tree rooted at largest
		exchange(arr, i, largest);
		maxHeapify(arr, largest, heapsize);
	}
}

int extractMax(int *arr, int *heapsize) {
	if (*heapsize < 1) {
		printf("ERROR: heap is empty. Nothing to return.\n");
		return INT_MIN; // int placeholder for -inf
	} 
	else {
		int max = arr[0];
		// swap root with last item, get rid of last item
		int last = arr[*heapsize-1];
		arr[0] = last;
		*heapsize = *heapsize - 1;
		maxHeapify(arr, 0, heapsize);
		return max;
	}
}
		\end{lstlisting} 
		
		\textbf{\texttt{extractMax()} runtime analysis:}
		\begin{itemize}
		\item \texttt{int max} is found in constant time (always the root).
		
		\item \texttt{maxHeapify()} is recursively called, starting with the root position; worst case, the value there needs to bubble all the way to the bottom of the tree, or \textit{h} times.
		Per question b, height of a d-ary tree is $\theta(log_{d}(n))$.
		
		\item Therefore worst-case runtime of \texttt{extractMax()} for d-ary tree is $O(log_{d}(n))$.
		
		\end{itemize}
		\newpage
		\item Implementation of increaseKey():
\begin{lstlisting}[language=C,style=CStyle]
void increaseKey(int *arr, int i, int key) {
	if (key < arr[i]){ printf("ERROR: %d is less than current arr[i] %d\n", key, i); }
	else {
		arr[i] = key;
		while (i > 0) {
			int j = (i-1) / DARY; // parent
			if (arr[j] >= arr[i]) {
				break; // parent is greater, all is well
			} else {
				// parent is smaller; swap them
				exchange(arr, i, j);
				i = j;
			}
		}
	}
}
\end{lstlisting}
		
		\textbf{\texttt{increaseKey()} runtime analysis:}
		\begin{itemize}
		\item The \texttt{while} loop runs as long as the current node (at position i) being checked has a parent, and while \texttt{arr[i]} is greater than its parent. The max number of times this can happen is the \# of edges between \texttt{i} and the root. Worst case, \texttt{i} is at the bottom of the tree, meaning the loop can occur maximum \textit{h} times, where \textit{h} is the height of the tree.
		\item Per question b, height of a d-ary tree is $\theta(log_{d}(n))$.
		\item Therefore worst-case runtime of \texttt{increaseKey()} for d-ary tree is $O(log_{d}(n))$.
		\end{itemize}
		
		\item Implementation of \texttt{insert()}:
\begin{lstlisting}[language=C,style=CStyle]
define MAX 10; // <- to help malloc space for array
void insert(int *arr, int key, int *heapsize) {
	if (*heapsize == MAX) {
		printf("ERROR: Heap at max size %d\n", *heapsize);
	} else {
		*heapsize = *heapsize + 1; // expand queue by 1
		arr[*heapsize-1] = INT_MIN; // set new, last item to large negative value
		increaseKey(arr, *heapsize-1, key); // update its priority to "key" and bubble up to right place
	}
}
\end{lstlisting}
\textbf{\texttt{insert()} runtime analysis:}
		\begin{itemize}
		\item \texttt{insert()} makes a single call to \texttt{increaseKey()} after adding the new value to the end of the array. All other lines run in constant time.
		\item Per question d above, \texttt{increaseKey()} worst-case runtime is $O(log_{d}(n))$, so \texttt{insert()} also runs in $O(log_{d}(n))$.
		\end{itemize}
		
		\end{enumerate}
		
\newpage	
	\item 
	\begin{enumerate}
	\item reverse Young Tableau:
	\begin{center}
	\begin{tabular}{| c | c | c | c |}
	\hline
 	15 & 14 & 8 & 4 \\ 
 	\hline
 	12 & 9 & 5 & $-\infty$ \\  
 	\hline
 	3 & $-\infty$ & $-\infty$ & $-\infty$  \\
 	\hline
 	1 & $-\infty$ & $-\infty$ & $-\infty$  \\
 	\hline 
	\end{tabular}
	\end{center}
	
	\item \textbf{The definition of an empty reverse Young tableau} is that all elements are nonexistent = $-\infty$. \\
	
	A reverse Young Tableau requires that in an $m \times n$ tableau:
	
	\[Y[a,b] \geq Y[a+i, b+j] \]
	for \\ 
	$a = 1,2,...,m$ \\
	$b = 1,2,...,n$ \\ 
	$i = 1,2,...m-a$\\ 
	$j = 1,2,...n-b$ \\
	
	There exist no values smaller than -$\infty$; therefore the only tableau that satisfies this constraint for $Y[1,1]$ = -$\infty$ is if all other elements are also -$\infty$.\\
	
	\textbf{The definition of a full reverse Young tableau} is that no elements are $-\infty$. \\
	
	If $Y[m,n] > -\infty$, all elements $Y[a,b]$ for $a\leq m$ and $b\leq n$ must be $\geq$ $Y[m,n]$, or $> -\infty$. Therefore no elements are empty and the tableau must be full.
	
	\item Again, will put here a working implementation in C. Not all function definitions are shown.
	
	\begin{lstlisting}[language=C, style=CStyle]
int extractMax(tableau *t) {
	int max = t->elements[0];
	if(max == -INT_MAX){
		printf("ERROR: tableau is empty. No max to return\n");
	} else {
		int last = t->m*t->n-1;
		// swap max and last item (smallest)
		exchange(t, 0, last);
		// empty out the last position
		t->elements[last] = -INT_MAX;
		// recursively bubble down the element at 0th position
		cell topLeftCell = cellAt(1,1);
		bubbleDown(t, topLeftCell);
	}
	return max;	
}

void bubbleDown(tableau *t, cell c) {
// Compare down, compare right. 
// If smaller than either/both, exchange w larger item
// Then call itself on the newly exchanged cells

	cell pos = c; // track position in the tableau
	int c_v = get(t,c); // get c's value

	char look; // which directions can we look?
	cell d = lookDown(c);
	cell r = lookRight(c);
	
	\end{lstlisting}
	\newpage
	\begin{lstlisting}[language=C, style=CStyle]
	
	if(isIn(t,d)) {
		if(isIn(t,r)) { look = 'b'; } // can look both ways
		else { look = 'd'; }  // look down
	} else {
		if(isIn(t,r)){ look = 'r'; } // look right
	}

	char exch; // which exchange case are we doing?
	int d_v;
	int r_v;

	switch(look) {
		case 'b': // look both ways
			d_v = get(t, d);
			r_v = get(t, r);

			if (c_v >= d_v && c_v >= r_v) { ; } // all is ok
			else if (c_v < d_v && c_v >= r_v) { exch = 'd'; }	
			else if (c_v < r_v && c_v >= d_v) { exch = 'r'; }
			else { // smaller than both; swap with bigger one
				if (r_v > d_v) { exch = 'r'; }
				else { exch = 'd'; }
			}
			break;
		case 'r': // check r
			r_v = get(t, r);
			if (c_v < r_v) { exch = 'r'; }
			break;
		case 'd': //check d
			d_v = get(t, d);
			if (c_v < d_v) { exch = 'd'; }
			break;
	}

	// do exchange
	switch(exch) {
		case 'd':
			exchange(t, getIndex(t, c), getIndex(t, d));
			pos = d;
			break;
		case 'r':
			exchange(t, getIndex(t, c), getIndex(t, r));
			pos = r;
			break;
		default:
			break; // no exchange
	}

	// if exchanged, recursively call bubbleDown on the two exchanged positions
	if (0 == cellsEqual(t, pos, c)) { 
		bubbleDown(t, pos);
		bubbleDown(t, c); }

	\end{lstlisting}
	
	\textbf{Runtime analysis of \texttt{extractMax()}:}
	\begin{itemize}
		\item Finding max happens in constant time (first item in the array).
	\item \texttt{bubbleDown()} from any given cell can occur a maximum of $m-1$ times towards the right, and $n-1$ times downwards.
	\item Therefore worst-case runtime of extractMax() is $O(m+n)$. 
	\end{itemize}	
	
	\newpage
	\item Again, C implementation of insertion:
	
	\begin{lstlisting}[language=C, style=CStyle]
void insert(tableau *t, int value) {
	int bottomRight = t->elements[t->m*t->n-1];
	// always put at bottom-right most position and bubble up
	if(bottomRight != -INT_MAX) {
	// tableau is full
		printf("ERROR: tableau full, cannot insert\n");
	}
	else {
		t->elements[t->m*t->n-1] = value;
		cell bottomRightCell = cellAt(t->m, t->n);
		bubbleUp(t, bottomRightCell);
	}
}

// bubbleUp() code is the mirror image of bubbleDown() in the opposite directions (up and to the left) - won't include again here
	\end{lstlisting}
	
	\textbf{Runtime analysis of \texttt{insert()}:}
	\begin{itemize}
		\item Checking bottom right for non-fullness and adding an element happens in constant time.
	\item \texttt{bubbleUp()} code is equivalent to \texttt{bubbleDown()} code in the opposite direction. Any given cell can bubble up a maximum of $m-1$ times towards the left, and $n-1$ times upwards.
	\item Therefore worst-case runtime of insert() is $O(m+n)$. 
	\end{itemize} 
	
	\item C implementation of search:
	
	\begin{lstlisting}[language=C, style=CStyle]
int search(tableau *t, cell c, int value) {
	// start top right
	// if too big, everything to its left is also too big, so check the next row
	// if too small, everything below it is by def too small, so move left
	// repeat until found or have eliminated entire tableau
	cell current = c;
	int cur_val = get(t, c);

	if (cur_val == value) {
		int index = getIndex(t, current);
		printf("found at getIndex() = %d\n", index);
		return index;
	} else if (cur_val > value) {
		// go down a row
		current.j += 1;
	} else {
		// go left a column
		current.i -=1;
	}
	// as long as new cell is valid, recurse on search
	if (isIn(t, current)) {
		return search(t, current, value);
	}
	// if all of the above fails to return anything
	return -1;
}

int searchFromStart(tableau *t, int value) {
	cell startCell = cellAt(t->m, 1);
	return search(t, startCell, value);
}	\end{lstlisting}

\textbf{Runtime analysis of \texttt{search()}:}
	\begin{itemize}
		\item Making comparisons of current value against search value occur in constant time.
	\item \texttt{search()} recurs every time we move down or move left and still find a valid cell inside the tableau. By definition if we start from the top right cell, this can only happen (m-1) + (n-1) times.
	\item Therefore worst-case runtime of search() is $O(m+n)$.
	\end{itemize}
	
	\item This is pretty straightforward: we run \texttt{extractMax()} over and over and output the values in order until the Young tableau is empty. This outputs a reverse sorted list; we can flip it if needed by reading this list backwards (which will add $O(n^2)$ steps).
	
	\begin{lstlisting}[language=C, style=CStyle]
	void sort(tableau * t) {
	int dim = (t->m) * (t->n); 
	for (int i = 0; i < dim; i++) {
		printf("%d ",extractMax(t)); // or add this to another array etc
		}
	}
	\end{lstlisting}
	\textbf{Runtime analysis of \texttt{sort()}:}
	\begin{itemize}
		\item Per question c, each call to \texttt{extractMax()} runs in $O(m+n)$, or $O(2n)$ for $m=n$.
		\item We run \texttt{extractMax()} once for each item in the tableau, which is $n \times m = n^2$ for $n=m$.
	\item Therefore worst-case runtime of sort() is $O(n \times n^2) = O(n^3)$.
	\end{itemize}
	
	\end{enumerate}
	
	\item The solution is basically to use an in-order graph walk to count the number of items and push the in-order values into a stack. We then return item $n/2$ from that stack.
	
	\begin{lstlisting}
	inOrderWalkCount(Node x, int counter, Stack stack) {
		if(x != NULL ) {

		// initially called with x = root
		Node left = x.left;
		Node right = x.right;

		inOrderWalkCount(left, counter, stack);
		stack.push(x.value);
		counter += 1;
		inOrderWalkCount(right, counter, stack);
		}
	}

	int findMedian(Node x) {
		// returns median of tree rooted at x
		// so call this on root
		int counter = 0;
		Stack stack = new Stack; // stack of ints		
		
		inOrderWalkCount(x, counter, stack);
		int medianIndex;
		if (counter % 2 == 0) { // even
			medianIndex = counter / 2;
		}
		else {
			medianIndex = (counter + 1 / 2); // use ceiling, per assignment definition
		}

		// pop items from stack until just before the median
		for (int i = 1; i < medianIndex; i++) {
			stack.pop();
		}
	
		return stack.pop();
	\end{lstlisting}
	\textbf{Runtime analysis of \texttt{findMedian()}:}
	\begin{itemize}
		\item \texttt{inOrderWalkCount()} runs in $O(n)$ time (since we simply traverse every item in the tree).
		\item \texttt{stack.pop()} runs $n/2$ times.
	\item Therefore worst-case runtime of \texttt{inOrderWalkCount()} is $O(n + n/2) = O(n)$.
	\end{itemize}   
	
\end{enumerate}

\end{document}
